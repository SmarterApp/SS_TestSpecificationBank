/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testspecbank.service.impl;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.opentestsystem.authoring.testspecbank.service.FileManagerService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service("fileManagerService")
public class FileManagerServiceImpl implements FileManagerService {
    /** logger. */
    private static final Logger LOGGER = LoggerFactory.getLogger(FileManagerServiceImpl.class);

    private static final int BUFFER_SIZE = 1024;

    @Value(value = "${tsb.download.directory:}")
    private String tempFileDirectory;

    @Override
    public File initializeCleanDirectory(final String directoryName) {
        final File downloadDir = new File(tempFileDirectory + directoryName);
        downloadDir.mkdir();

        try {
            FileUtils.cleanDirectory(downloadDir);
        } catch (final IOException e) {
            LOGGER.error("unable to initialize local directory", e);
            throw new LocalizedException("localFile.directory.init", new String[] { tempFileDirectory + directoryName });
        }
        return downloadDir;
    }

    @Override
    public File initializeFile(final String parentDirectoryName, final String fileName) {
        return new File(tempFileDirectory + parentDirectoryName, parseBaseFileName(fileName));
    }

    @Override
    public String getFullPath(final String relativeFilePath) {
        return tempFileDirectory + relativeFilePath;
    }

    @Override
    public void writeFile(final String filePath, final byte[] sourceXml) {
        FileOutputStream specFos = null;
        BufferedOutputStream specBos = null;
        try {
            specFos = new FileOutputStream(tempFileDirectory + filePath);
            specBos = new BufferedOutputStream(specFos);
            specBos.write(sourceXml);
        } catch (final IOException e) {
            LOGGER.error("unable to write local file", e);
            throw new LocalizedException("localFile.write.fail", new String[] { tempFileDirectory + filePath });
        } finally {
            try {
                if (specBos != null) {
                    specBos.flush();
                    specBos.close();
                }
                if (specFos != null) {
                    specFos.flush();
                    specFos.close();
                }
            } catch (final IOException e) {
                LOGGER.error("unable to write local file", e);
                throw new LocalizedException("localFile.write.fail", new String[] { tempFileDirectory + filePath });
            }
        }
    }

    @Override
    public void buildZipFromDirectory(final File sourceDirectory, final String targetZipFileName) {
        FileOutputStream fos = null;
        BufferedOutputStream bos = null;
        ZipOutputStream zipOutputStream = null;
        try {
            // create zip output file stream
            fos = new FileOutputStream(tempFileDirectory + targetZipFileName);
            bos = new BufferedOutputStream(fos);
            zipOutputStream = new ZipOutputStream(bos);

            // for each downloaded file...
            for (final File file : sourceDirectory.listFiles()) {
                FileInputStream fis = null;
                try {
                    // create new zip entry
                    fis = new FileInputStream(file);
                    zipOutputStream.putNextEntry(new ZipEntry(file.getName()));

                    // write file contents to zip
                    final byte[] buf = new byte[BUFFER_SIZE];
                    int readLen = 0;
                    while ((readLen = fis.read(buf)) > 0) {
                        zipOutputStream.write(buf, 0, readLen);
                    }
                } catch (final IOException e) {
                    throw new LocalizedException("localFile.zip.entry.fail", new String[] { file.getName() });
                } finally {
                    if (fis != null) {
                        fis.close();
                    }
                    zipOutputStream.closeEntry();
                }
            }
        } catch (final IOException e) {
            throw new LocalizedException("localFile.zip.fail", new String[] { targetZipFileName });
        } finally {
            try {
                if (zipOutputStream != null) {
                    zipOutputStream.flush();
                    zipOutputStream.close();
                }
                if (bos != null) {
                    bos.flush();
                    bos.close();
                }
                if (fos != null) {
                    fos.flush();
                    fos.close();
                }
            } catch (final IOException e) {
                throw new LocalizedException("localFile.zip.fail", new String[] { targetZipFileName });
            }
        }
    }

    private static final String parseBaseFileName(final String filePath) {
        return FilenameUtils.getBaseName(filePath) + "." + FilenameUtils.getExtension(filePath);
    }

}
