/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testspecbank.client;

import com.google.common.collect.ImmutableSet;
import org.codehaus.jackson.annotate.JsonAutoDetect;
import org.codehaus.jackson.annotate.JsonMethod;
import org.codehaus.jackson.map.ObjectMapper;
import org.hamcrest.BaseMatcher;
import org.hamcrest.CoreMatchers;
import org.hamcrest.Description;
import org.junit.Test;
import org.opentestsystem.authoring.testspecbank.client.domain.TestSpecBankClientObj;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;

import java.beans.Visibility;
import java.net.URI;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import tds.common.ValidationError;

import static java.util.Arrays.asList;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.method;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withServerError;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withStatus;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;

/**
 * Test out the server profile which requires an externally defined properties file.
 * Tests are ignored since this really isn't portable.
 */
public class TestSpecBankClientTest extends AbstractClientTest {

    @Test
    public void clientIsValid() {
        assertThat(this.client, notNullValue());
    }

    @Test
    public void getTestSpecificationByTenantIdWithSuccess() throws InterruptedException {
        final String testSpecification1 = "{" +
            "\"searchResults\" : [{ \"id\": \"testSpecification1\", \"tenantSet\": \"123\" }]," +
            "\"currentPage\" : 0," +
            "\"returnCount\" : 0," +
            "\"pageSize\" : 10," +
            "\"totalCount\" : 0," +
            "\"sortKey\" : \"name\"," +
            "\"sortDirection\" : \"ASC\"," +
            "\"nextPageUrl\" : null," +
            "\"prevPageUrl\" : null" +
            "}";
        this.mockServer
            .expect(requestTo(new UriMatcher("testSpecification?tenantSet=123")))
            .andExpect(method(HttpMethod.GET))
            .andRespond(withSuccess(testSpecification1, MediaType.APPLICATION_JSON));

        final SearchResponse<TestSpecBankClientObj> foundTestSpecBankClientObj = this.client.getTestSpecificationByTenantSet(ImmutableSet.of("123"), null);
        assertThat(foundTestSpecBankClientObj, is(not(nullValue())));
    }

    @Test
    public void getTestSpecificationBySubjectAbbreviationWithSuccess() throws InterruptedException {
        final String testSpecification1 = "{" +
            "\"searchResults\" : [{ \"id\": \"testSpecification1\", \"tenantSet\": \"123\", \"subjectAbbreviation\": \"mySubject\" }]," +
            "\"currentPage\" : 0," +
            "\"returnCount\" : 0," +
            "\"pageSize\" : 10," +
            "\"totalCount\" : 0," +
            "\"sortKey\" : \"name\"," +
            "\"sortDirection\" : \"ASC\"," +
            "\"nextPageUrl\" : null," +
            "\"prevPageUrl\" : null" +
            "}";

        this.mockServer
            .expect(requestTo(new UriMatcher("testSpecification?subjectAbbreviation=mySubject&tenantSet=123")))
            .andExpect(method(HttpMethod.GET))
            .andRespond(withSuccess(testSpecification1, MediaType.APPLICATION_JSON));

        final Map<String, String[]> subjectMap = new HashMap<String, String[]>();
        subjectMap.put("subjectAbbreviation", new String[]{"mySubject"});
        final SearchResponse<TestSpecBankClientObj> foundTestSpecBankClientObj = this.client.getTestSpecificationByTenantSet(ImmutableSet.of("123"), subjectMap);
        assertThat(foundTestSpecBankClientObj, is(not(nullValue())));
    }

    @Test
    public void publishTestSpecificationWithSuccess() throws InterruptedException {
        final TestSpecBankClientObj testSpecificationToSave = FACTORY.manufacturePojo(TestSpecBankClientObj.class);
        final String testSpecification1 = "{ \"id\": \"testSpecification1\" }";
        this.mockServer
            .expect(requestTo(new UriMatcher("testSpecification")))
            .andExpect(method(HttpMethod.POST))
            .andRespond(withSuccess(testSpecification1, MediaType.APPLICATION_JSON));
        final TestSpecBankClientObj foundTestSpecBankClientObj = this.client.publishTestSpecification(testSpecificationToSave);
        assertThat(foundTestSpecBankClientObj, is(not(nullValue())));
    }

    @Test
    public void shouldDeleteATestSpecification() throws InterruptedException {
        final String testSpecificationKey = "delete-me";
        mockServer.expect(requestTo(new UriMatcher(String.format("testSpecification/%s", testSpecificationKey))))
            .andExpect(method(HttpMethod.DELETE))
            .andRespond(withStatus(HttpStatus.NO_CONTENT));

        final Optional<ValidationError> result = client.deleteTestSpecification(testSpecificationKey);

        assertThat(result.isPresent(), is(false));
    }

    @Test
    public void shouldIndicateFailureAndReasoneWhenDeletingATestSpecificationThatCannotBeFound() throws Exception {
        final String testSpecificationKey = "delete-me";
        final ValidationError expectedError = new ValidationError("notFound", "Could not find test specification for key 'delete-me'");
        final ObjectMapper jsonMapper = new ObjectMapper();

        mockServer.expect(requestTo(new UriMatcher(String.format("testSpecification/%s", testSpecificationKey))))
            .andExpect(method(HttpMethod.DELETE))
            .andRespond(withStatus(HttpStatus.UNPROCESSABLE_ENTITY)
                .contentType(MediaType.APPLICATION_JSON)
                .body(jsonMapper.writeValueAsString(expectedError)));

        final Optional<ValidationError> result = client.deleteTestSpecification(testSpecificationKey);

        assertThat(result.isPresent(), is(true));
        assertThat(result.get().getCode(), is(expectedError.getCode()));
        assertThat(result.get().getMessage(), is(expectedError.getMessage()));
    }

    @Test
    public void shouldIndicateFailureAndReasonWhenAnInternalServerErrorIsEncountered() throws Exception {
        final String testSpecificationKey = "delete-me";

        mockServer.expect(requestTo(new UriMatcher(String.format("testSpecification/%s", testSpecificationKey))))
            .andExpect(method(HttpMethod.DELETE))
            .andRespond(withServerError()
                .contentType(MediaType.APPLICATION_JSON));

        final Optional<ValidationError> result = client.deleteTestSpecification(testSpecificationKey);

        assertThat(result.isPresent(), is(true));
        assertThat(result.get().getCode(), is("server exception"));
        assertThat(result.get().getMessage(), is("500 Internal Server Error"));
    }

    @Test
    public void shouldDeserializeJsonStringToValidationError() throws Exception {
        final String jsonResponse = "{\n" +
            "  \"errors\" : [ {\n" +
            "    \"code\" : \"notFound\",\n" +
            "    \"message\" : \"Could not find test specification for key '(SBAC_PT)IRP-Perf-ELA-7-Summer-2015-2016'\",\n" +
            "    \"translatedMessage\" : {\n" +
            "      \"present\" : false\n" +
            "    }\n" +
            "  } ]\n" +
            "}";

        final ObjectMapper objectMapper = new ObjectMapper().setVisibility(JsonMethod.FIELD, JsonAutoDetect.Visibility.ANY);
        final ValidationError validationError = objectMapper.readValue(jsonResponse, ValidationError.class);

        assertThat(validationError.getCode(), is("notFound"));
        assertThat(validationError.getMessage(), is("Could not find test specification for key '(SBAC_PT)IRP-Perf-ELA-7-Summer-2015-2016'"));
    }

    private static class UriMatcher extends BaseMatcher<String> {

        private final URI expected;

        UriMatcher(final String expectedUri) {
            expected = URI.create(expectedUri);
        }

        @Override
        public boolean matches(final Object o) {
            if (!(o instanceof String)) {
                return false;
            }
            final URI value = URI.create((String) o);

            final Set<String> expectedParams = expected.getQuery() == null
                ? new HashSet<String>()
                : new HashSet<>(asList(expected.getQuery().split("\\&")));
            final Set<String> actualParams = value.getQuery() == null
                ? new HashSet<String>()
                : new HashSet<>(asList(value.getQuery().split("\\&")));

            return Objects.equals(expected.getScheme(), value.getScheme()) &&
                Objects.equals(expected.getPath(), value.getPath()) &&
                CoreMatchers.hasItems(expectedParams.toArray()).matches(actualParams);
        }

        @Override
        public void describeTo(final Description description) {
            description
                .appendText("Expected URI matching: ")
                .appendValue(expected);
        }
    }
}
